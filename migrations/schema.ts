import { pgTable, foreignKey, serial, integer, varchar, numeric, date, timestamp, unique, boolean, index, text, jsonb, json, check } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const plaidHoldings = pgTable("plaid_holdings", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	accountId: varchar("account_id", { length: 255 }).notNull(),
	securityId: varchar("security_id", { length: 255 }),
	institutionPrice: numeric("institution_price", { precision: 12, scale:  4 }),
	institutionPriceAsOf: date("institution_price_as_of"),
	institutionValue: numeric("institution_value", { precision: 12, scale:  2 }),
	costBasis: numeric("cost_basis", { precision: 12, scale:  2 }),
	quantity: numeric({ precision: 12, scale:  4 }),
	isoCurrencyCode: varchar("iso_currency_code", { length: 3 }),
	unofficialCurrencyCode: varchar("unofficial_currency_code", { length: 10 }),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_holdings_user_id_fkey"
		}).onDelete("cascade"),
]);

export const plaidSecurities = pgTable("plaid_securities", {
	id: serial().primaryKey().notNull(),
	securityId: varchar("security_id", { length: 255 }).notNull(),
	isin: varchar({ length: 12 }),
	cusip: varchar({ length: 9 }),
	sedol: varchar({ length: 7 }),
	institutionSecurityId: varchar("institution_security_id", { length: 255 }),
	institutionId: varchar("institution_id", { length: 255 }),
	proxySecurityId: varchar("proxy_security_id", { length: 255 }),
	name: varchar({ length: 255 }),
	tickerSymbol: varchar("ticker_symbol", { length: 10 }),
	isCashEquivalent: boolean("is_cash_equivalent").default(false),
	type: varchar({ length: 50 }),
	closePrice: numeric("close_price", { precision: 12, scale:  4 }),
	closePriceAsOf: date("close_price_as_of"),
	isoCurrencyCode: varchar("iso_currency_code", { length: 3 }),
	unofficialCurrencyCode: varchar("unofficial_currency_code", { length: 10 }),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	unique("plaid_securities_security_id_key").on(table.securityId),
]);

export const goals = pgTable("goals", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	title: varchar({ length: 255 }).notNull(),
	description: text(),
	targetAmount: numeric("target_amount", { precision: 12, scale:  2 }),
	currentAmount: numeric("current_amount", { precision: 12, scale:  2 }).default('0'),
	targetDate: date("target_date"),
	category: varchar({ length: 50 }),
	priority: varchar({ length: 20 }).default('medium'),
	status: varchar({ length: 20 }).default('active'),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	index("idx_goals_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "goals_user_id_fkey"
		}).onDelete("cascade"),
]);

export const lifeGoals = pgTable("life_goals", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	goalType: varchar("goal_type", { length: 50 }).notNull(),
	goalName: varchar("goal_name", { length: 255 }).notNull(),
	targetAge: integer("target_age"),
	targetAmount: numeric("target_amount", { precision: 12, scale:  2 }),
	oneTimeExpense: boolean("one_time_expense").default(true),
	annualExpenseAmount: numeric("annual_expense_amount", { precision: 12, scale:  2 }),
	expenseDurationYears: integer("expense_duration_years"),
	priority: varchar({ length: 20 }).default('medium'),
	notes: text(),
	fundingSources: jsonb("funding_sources"),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	index("idx_life_goals_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "life_goals_user_id_fkey"
		}).onDelete("cascade"),
]);

export const chatMessages = pgTable("chat_messages", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	message: text().notNull(),
	sender: varchar({ length: 10 }).notNull(),
	timestamp: timestamp({ mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	conversationId: varchar("conversation_id", { length: 255 }),
	metadata: jsonb(),
}, (table) => [
	index("idx_chat_messages_conversation_id").using("btree", table.conversationId.asc().nullsLast().op("text_ops")),
	index("idx_chat_messages_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "chat_messages_user_id_fkey"
		}).onDelete("cascade"),
]);

export const pdfReports = pgTable("pdf_reports", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	reportType: varchar("report_type", { length: 50 }).notNull(),
	reportData: jsonb("report_data").notNull(),
	filePath: varchar("file_path", { length: 500 }),
	generatedAt: timestamp("generated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "pdf_reports_user_id_fkey"
		}).onDelete("cascade"),
]);

export const educationGoals = pgTable("education_goals", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	childName: varchar("child_name", { length: 255 }).notNull(),
	childAge: integer("child_age").notNull(),
	collegeStartYear: integer("college_start_year").notNull(),
	collegeType: varchar("college_type", { length: 50 }),
	estimatedAnnualCost: numeric("estimated_annual_cost", { precision: 12, scale:  2 }),
	yearsOfEducation: integer("years_of_education").default(4),
	currentSavings: numeric("current_savings", { precision: 12, scale:  2 }).default('0'),
	monthlyContribution: numeric("monthly_contribution", { precision: 12, scale:  2 }).default('0'),
	stateOfResidence: varchar("state_of_residence", { length: 2 }),
	state529Plan: varchar("state_529_plan", { length: 100 }),
	fundingSources: jsonb("funding_sources"),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	index("idx_education_goals_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "education_goals_user_id_fkey"
		}).onDelete("cascade"),
]);

export const estatePlans = pgTable("estate_plans", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	hasWill: boolean("has_will").default(false),
	willLastUpdated: date("will_last_updated"),
	hasTrust: boolean("has_trust").default(false),
	trustType: varchar("trust_type", { length: 100 }),
	hasPowerOfAttorney: boolean("has_power_of_attorney").default(false),
	hasHealthcareDirective: boolean("has_healthcare_directive").default(false),
	executorName: varchar("executor_name", { length: 255 }),
	executorRelationship: varchar("executor_relationship", { length: 100 }),
	notes: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "estate_plans_user_id_fkey"
		}).onDelete("cascade"),
]);

export const estateBeneficiaries = pgTable("estate_beneficiaries", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	accountType: varchar("account_type", { length: 100 }).notNull(),
	accountName: varchar("account_name", { length: 255 }).notNull(),
	primaryBeneficiary: varchar("primary_beneficiary", { length: 255 }),
	primaryBeneficiaryRelationship: varchar("primary_beneficiary_relationship", { length: 100 }),
	primaryBeneficiaryPercentage: numeric("primary_beneficiary_percentage", { precision: 5, scale:  2 }),
	contingentBeneficiary: varchar("contingent_beneficiary", { length: 255 }),
	contingentBeneficiaryRelationship: varchar("contingent_beneficiary_relationship", { length: 100 }),
	contingentBeneficiaryPercentage: numeric("contingent_beneficiary_percentage", { precision: 5, scale:  2 }),
	lastUpdated: date("last_updated"),
	notes: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "estate_beneficiaries_user_id_fkey"
		}).onDelete("cascade"),
]);

export const investmentCache = pgTable("investment_cache", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	cacheKey: varchar("cache_key", { length: 255 }).notNull(),
	cacheValue: jsonb("cache_value").notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	expiresAt: timestamp("expires_at", { mode: 'string' }),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "investment_cache_user_id_fkey"
		}).onDelete("cascade"),
	unique("investment_cache_user_id_cache_key_key").on(table.userId, table.cacheKey),
]);

export const plaidItems = pgTable("plaid_items", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	accessToken: text("access_token").notNull(),
	itemId: varchar("item_id", { length: 255 }).notNull(),
	institutionId: varchar("institution_id", { length: 255 }),
	institutionName: varchar("institution_name", { length: 255 }),
	cursor: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	status: text().default('active'),
	errorCode: text("error_code"),
	errorMessage: text("error_message"),
	consentExpirationTime: timestamp("consent_expiration_time", { mode: 'string' }),
	lastSuccessfulUpdate: timestamp("last_successful_update", { mode: 'string' }),
	lastFailedUpdate: timestamp("last_failed_update", { mode: 'string' }),
}, (table) => [
	index("idx_plaid_items_item_id").using("btree", table.itemId.asc().nullsLast().op("text_ops")),
	index("idx_plaid_items_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_items_user_id_fkey"
		}).onDelete("cascade"),
	unique("plaid_items_user_id_item_id_key").on(table.userId, table.itemId),
]);

export const plaidAccounts = pgTable("plaid_accounts", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	itemId: varchar("item_id", { length: 255 }),
	accountId: varchar("account_id", { length: 255 }).notNull(),
	name: varchar({ length: 255 }),
	officialName: varchar("official_name", { length: 255 }),
	type: varchar({ length: 50 }),
	subtype: varchar({ length: 50 }),
	mask: varchar({ length: 10 }),
	currentBalance: numeric("current_balance", { precision: 12, scale:  2 }),
	availableBalance: numeric("available_balance", { precision: 12, scale:  2 }),
	isoCurrencyCode: varchar("iso_currency_code", { length: 3 }),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	plaidItemId: integer("plaid_item_id"),
	accountName: text("account_name"),
	accountType: text("account_type"),
	accountSubtype: text("account_subtype"),
	creditLimit: numeric("credit_limit", { precision: 12, scale:  2 }),
	currency: text().default('USD'),
	isActive: boolean("is_active").default(true),
	lastSynced: timestamp("last_synced", { mode: 'string' }),
	metadata: jsonb(),
	balances: jsonb(),
	owners: jsonb(),
}, (table) => [
	index("idx_plaid_accounts_is_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("idx_plaid_accounts_plaid_item_id").using("btree", table.plaidItemId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_accounts_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.plaidItemId],
			foreignColumns: [plaidItems.id],
			name: "plaid_accounts_plaid_item_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_accounts_user_id_fkey"
		}).onDelete("cascade"),
	unique("plaid_accounts_account_id_key").on(table.accountId),
]);

export const plaidTransactions = pgTable("plaid_transactions", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	accountId: varchar("account_id", { length: 255 }).notNull(),
	transactionId: varchar("transaction_id", { length: 255 }).notNull(),
	amount: numeric({ precision: 12, scale:  2 }),
	isoCurrencyCode: varchar("iso_currency_code", { length: 3 }),
	category: jsonb(),
	categoryId: varchar("category_id", { length: 50 }),
	date: date(),
	authorizedDate: date("authorized_date"),
	name: varchar({ length: 255 }),
	merchantName: varchar("merchant_name", { length: 255 }),
	paymentChannel: varchar("payment_channel", { length: 50 }),
	pending: boolean().default(false),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	plaidAccountId: integer("plaid_account_id"),
	primaryCategory: text("primary_category"),
}, (table) => [
	index("idx_plaid_transactions_category").using("btree", table.primaryCategory.asc().nullsLast().op("text_ops")),
	index("idx_plaid_transactions_date").using("btree", table.date.asc().nullsLast().op("date_ops")),
	index("idx_plaid_transactions_plaid_account_id").using("btree", table.plaidAccountId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_transactions_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.plaidAccountId],
			foreignColumns: [plaidAccounts.id],
			name: "plaid_transactions_plaid_account_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_transactions_user_id_fkey"
		}).onDelete("cascade"),
	unique("plaid_transactions_transaction_id_key").on(table.transactionId),
]);

export const session = pgTable("session", {
	sid: varchar().primaryKey().notNull(),
	sess: json().notNull(),
	expire: timestamp({ precision: 6, mode: 'string' }).notNull(),
}, (table) => [
	index("idx_session_expire").using("btree", table.expire.asc().nullsLast().op("timestamp_ops")),
]);

export const sectionProgress = pgTable("section_progress", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	sectionName: varchar("section_name", { length: 100 }),
	completionPercentage: integer("completion_percentage").default(0),
	lastUpdated: timestamp("last_updated", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	section: text().notNull(),
	visits: integer().default(0),
	timeSpent: integer("time_spent").default(0),
	actionsCompleted: integer("actions_completed").default(0),
	lastVisit: timestamp("last_visit", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	sectionType: varchar("section_type", { length: 100 }),
	fieldsCompleted: integer("fields_completed").default(0),
	totalFields: integer("total_fields").default(0),
	timeSpentSeconds: integer("time_spent_seconds").default(0),
	lastActivity: timestamp("last_activity", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "section_progress_user_id_fkey"
		}).onDelete("cascade"),
	unique("section_progress_user_id_section_name_key").on(table.userId, table.sectionName),
]);

export const userProgress = pgTable("user_progress", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	totalXp: integer("total_xp").default(0),
	level: integer().default(1),
	currentStreak: integer("current_streak").default(0),
	longestStreak: integer("longest_streak").default(0),
	lastActivityDate: date("last_activity_date"),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	currentLevel: integer("current_level").default(1),
	lastVisit: timestamp("last_visit", { mode: 'string' }).defaultNow(),
	sessionStats: jsonb("session_stats").default({}),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "user_progress_user_id_fkey"
		}).onDelete("cascade"),
	unique("user_progress_user_id_key").on(table.userId),
]);

export const userAchievements = pgTable("user_achievements", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	achievementId: varchar("achievement_id", { length: 100 }).notNull(),
	unlockedAt: timestamp("unlocked_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	xpEarned: integer("xp_earned").default(0),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "user_achievements_user_id_fkey"
		}).onDelete("cascade"),
	unique("user_achievements_user_id_achievement_id_key").on(table.userId, table.achievementId),
]);

export const plaidSyncSchedule = pgTable("plaid_sync_schedule", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	syncFrequency: text("sync_frequency").default('monthly'),
	nextSyncDate: timestamp("next_sync_date", { withTimezone: true, mode: 'string' }),
	lastFullSync: timestamp("last_full_sync", { withTimezone: true, mode: 'string' }),
	lastPartialSync: timestamp("last_partial_sync", { withTimezone: true, mode: 'string' }),
	autoSyncEnabled: boolean("auto_sync_enabled").default(true),
	syncTransactions: boolean("sync_transactions").default(true),
	syncInvestments: boolean("sync_investments").default(true),
	syncLiabilities: boolean("sync_liabilities").default(true),
	transactionDaysToSync: integer("transaction_days_to_sync").default(30),
	manualSyncsToday: integer("manual_syncs_today").default(0),
	manualSyncResetDate: date("manual_sync_reset_date"),
	lastSyncStatus: text("last_sync_status"),
	lastSyncError: text("last_sync_error"),
	consecutiveFailures: integer("consecutive_failures").default(0),
	isPaused: boolean("is_paused").default(false),
	pauseReason: text("pause_reason"),
	pausedAt: timestamp("paused_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	notifyOnSync: boolean("notify_on_sync").default(true),
	notifyOnLargeChanges: boolean("notify_on_large_changes").default(true),
	largeChangeThreshold: numeric("large_change_threshold", { precision: 12, scale:  2 }).default('10000'),
}, (table) => [
	index("idx_plaid_sync_schedule_next_sync").using("btree", table.nextSyncDate.asc().nullsLast().op("timestamptz_ops")),
	index("idx_plaid_sync_schedule_status").using("btree", table.lastSyncStatus.asc().nullsLast().op("text_ops")),
	index("idx_plaid_sync_schedule_user").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_sync_schedule_user_id_fkey"
		}),
	unique("plaid_sync_schedule_user_id_key").on(table.userId),
]);

export const sessions = pgTable("sessions", {
	sid: varchar().primaryKey().notNull(),
	sess: json().notNull(),
	expire: timestamp({ precision: 6, mode: 'string' }).notNull(),
});

export const users = pgTable("users", {
	id: serial().primaryKey().notNull(),
	username: varchar({ length: 255 }),
	password: varchar({ length: 255 }).notNull(),
	email: varchar({ length: 255 }),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	isAdvisor: boolean("is_advisor").default(false),
	advisorId: integer("advisor_id"),
	fullName: text("full_name"),
	role: text().default('individual'),
}, (table) => [
	foreignKey({
			columns: [table.advisorId],
			foreignColumns: [table.id],
			name: "users_advisor_id_fkey"
		}),
	unique("users_username_key").on(table.username),
	unique("users_email_key").on(table.email),
]);

export const advisorInvites = pgTable("advisor_invites", {
	id: serial().primaryKey().notNull(),
	advisorId: integer("advisor_id").notNull(),
	email: varchar({ length: 255 }).notNull(),
	inviteToken: varchar("invite_token", { length: 255 }).notNull(),
	status: varchar({ length: 50 }).default('pending'),
	acceptedAt: timestamp("accepted_at", { mode: 'string' }),
	clientId: integer("client_id"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	expiresAt: timestamp("expires_at", { mode: 'string' }).default(sql`(now() + '30 days'::interval)`),
	tokenHash: varchar("token_hash", { length: 255 }),
}, (table) => [
	index("idx_advisor_invites_email").using("btree", table.email.asc().nullsLast().op("text_ops")),
	index("idx_advisor_invites_token").using("btree", table.inviteToken.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.advisorId],
			foreignColumns: [users.id],
			name: "advisor_invites_advisor_id_fkey"
		}),
	foreignKey({
			columns: [table.clientId],
			foreignColumns: [users.id],
			name: "advisor_invites_client_id_fkey"
		}),
	unique("advisor_invites_invite_token_key").on(table.inviteToken),
]);

export const estateDocuments = pgTable("estate_documents", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	documentType: varchar("document_type", { length: 100 }).notNull(),
	documentName: varchar("document_name", { length: 255 }).notNull(),
	uploadedAt: timestamp("uploaded_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	lastReviewed: date("last_reviewed"),
	expiryDate: date("expiry_date"),
	notes: text(),
	estatePlanId: integer("estate_plan_id"),
	description: text(),
	status: text().default('active'),
	executionDate: date("execution_date"),
	expirationDate: date("expiration_date"),
	lastReviewDate: timestamp("last_review_date", { mode: 'string' }),
	preparedBy: text("prepared_by"),
	witnesses: jsonb(),
	notarized: boolean().default(false),
	forSpouse: boolean("for_spouse").default(false),
	storageLocation: text("storage_location"),
	documentUrl: text("document_url"),
	parsedInsights: jsonb("parsed_insights"),
	reviewReminderDays: integer("review_reminder_days").default(365),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "estate_documents_user_id_fkey"
		}).onDelete("cascade"),
]);

export const plaidSyncStatus = pgTable("plaid_sync_status", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	lastAccountsSync: timestamp("last_accounts_sync", { mode: 'string' }),
	lastTransactionsSync: timestamp("last_transactions_sync", { mode: 'string' }),
	lastHoldingsSync: timestamp("last_holdings_sync", { mode: 'string' }),
	lastLiabilitiesSync: timestamp("last_liabilities_sync", { mode: 'string' }),
	transactionsCursor: text("transactions_cursor"),
	syncInProgress: boolean("sync_in_progress").default(false),
	lastError: text("last_error"),
	lastErrorAt: timestamp("last_error_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	autoSyncEnabled: boolean("auto_sync_enabled").default(true),
	notifyOnSync: boolean("notify_on_sync").default(true),
	notifyOnLargeChanges: boolean("notify_on_large_changes").default(true),
	largeChangeThreshold: numeric("large_change_threshold", { precision: 12, scale:  2 }).default('10000'),
	syncFrequency: text("sync_frequency").default('monthly'),
	nextSyncDate: timestamp("next_sync_date", { mode: 'string' }),
	lastFullSync: timestamp("last_full_sync", { mode: 'string' }),
	lastPartialSync: timestamp("last_partial_sync", { mode: 'string' }),
	syncTransactions: boolean("sync_transactions").default(true),
	syncInvestments: boolean("sync_investments").default(true),
	syncLiabilities: boolean("sync_liabilities").default(true),
	transactionDaysToSync: integer("transaction_days_to_sync").default(30),
	manualSyncsToday: integer("manual_syncs_today").default(0),
	manualSyncResetDate: date("manual_sync_reset_date"),
}, (table) => [
	index("idx_plaid_sync_status_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_sync_status_user_id_fkey"
		}),
	unique("plaid_sync_status_user_id_key").on(table.userId),
]);

export const financialProfiles = pgTable("financial_profiles", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	age: integer(),
	spouseAge: integer("spouse_age"),
	annualIncome: numeric("annual_income", { precision: 12, scale:  2 }),
	spouseAnnualIncome: numeric("spouse_annual_income", { precision: 12, scale:  2 }),
	monthlyExpenses: jsonb("monthly_expenses"),
	stateOfResidence: varchar("state_of_residence", { length: 2 }),
	retirementState: varchar("retirement_state", { length: 2 }),
	filingStatus: varchar("filing_status", { length: 50 }),
	checkingSavingsBalance: numeric("checking_savings_balance", { precision: 12, scale:  2 }),
	investmentAccountsBalance: numeric("investment_accounts_balance", { precision: 12, scale:  2 }),
	retirementAccounts401K: numeric("retirement_accounts_401k", { precision: 12, scale:  2 }),
	retirementAccountsIra: numeric("retirement_accounts_ira", { precision: 12, scale:  2 }),
	retirementAccountsRothIra: numeric("retirement_accounts_roth_ira", { precision: 12, scale:  2 }),
	spouseRetirementAccounts401K: numeric("spouse_retirement_accounts_401k", { precision: 12, scale:  2 }),
	spouseRetirementAccountsIra: numeric("spouse_retirement_accounts_ira", { precision: 12, scale:  2 }),
	spouseRetirementAccountsRothIra: numeric("spouse_retirement_accounts_roth_ira", { precision: 12, scale:  2 }),
	otherAssets: numeric("other_assets", { precision: 12, scale:  2 }),
	primaryResidenceValue: numeric("primary_residence_value", { precision: 12, scale:  2 }),
	otherRealEstateValue: numeric("other_real_estate_value", { precision: 12, scale:  2 }),
	mortgageBalance: numeric("mortgage_balance", { precision: 12, scale:  2 }),
	mortgagePayment: numeric("mortgage_payment", { precision: 12, scale:  2 }),
	mortgageRate: numeric("mortgage_rate", { precision: 5, scale:  2 }),
	mortgageYearsRemaining: integer("mortgage_years_remaining"),
	otherDebts: jsonb("other_debts").default([]),
	lifeInsuranceCoverage: numeric("life_insurance_coverage", { precision: 12, scale:  2 }),
	spouseLifeInsuranceCoverage: numeric("spouse_life_insurance_coverage", { precision: 12, scale:  2 }),
	disabilityInsuranceCoverage: numeric("disability_insurance_coverage", { precision: 12, scale:  2 }),
	spouseDisabilityInsuranceCoverage: numeric("spouse_disability_insurance_coverage", { precision: 12, scale:  2 }),
	longTermCareInsurance: boolean("long_term_care_insurance").default(false),
	spouseLongTermCareInsurance: boolean("spouse_long_term_care_insurance").default(false),
	desiredRetirementAge: integer("desired_retirement_age"),
	spouseDesiredRetirementAge: integer("spouse_desired_retirement_age"),
	socialSecurityClaimAge: integer("social_security_claim_age"),
	spouseSocialSecurityClaimAge: integer("spouse_social_security_claim_age"),
	expectedSocialSecurityBenefit: numeric("expected_social_security_benefit", { precision: 12, scale:  2 }),
	spouseExpectedSocialSecurityBenefit: numeric("spouse_expected_social_security_benefit", { precision: 12, scale:  2 }),
	expectedMonthlyExpensesRetirement: numeric("expected_monthly_expenses_retirement", { precision: 12, scale:  2 }),
	partTimeIncomeRetirement: numeric("part_time_income_retirement", { precision: 12, scale:  2 }),
	spousePartTimeIncomeRetirement: numeric("spouse_part_time_income_retirement", { precision: 12, scale:  2 }),
	expectedInflationRate: numeric("expected_inflation_rate", { precision: 5, scale:  2 }).default('2.5'),
	userHealthStatus: text("user_health_status").default('good'),
	spouseHealthStatus: text("spouse_health_status").default('good'),
	userGender: text("user_gender").default('male'),
	spouseGender: text("spouse_gender").default('female'),
	userLifeExpectancy: integer("user_life_expectancy"),
	spouseLifeExpectancy: integer("spouse_life_expectancy"),
	riskTolerance: varchar("risk_tolerance", { length: 50 }),
	spouseRiskTolerance: varchar("spouse_risk_tolerance", { length: 50 }),
	currentAssetAllocation: jsonb("current_asset_allocation"),
	spouseCurrentAssetAllocation: jsonb("spouse_current_asset_allocation"),
	recommendedAssetAllocation: jsonb("recommended_asset_allocation"),
	spouseRecommendedAssetAllocation: jsonb("spouse_recommended_asset_allocation"),
	retirementMonthlyContribution: numeric("retirement_monthly_contribution", { precision: 12, scale:  2 }),
	spouseRetirementMonthlyContribution: numeric("spouse_retirement_monthly_contribution", { precision: 12, scale:  2 }),
	employerMatchPercentage: numeric("employer_match_percentage", { precision: 5, scale:  2 }),
	spouseEmployerMatchPercentage: numeric("spouse_employer_match_percentage", { precision: 5, scale:  2 }),
	annualIraContribution: numeric("annual_ira_contribution", { precision: 12, scale:  2 }),
	spouseAnnualIraContribution: numeric("spouse_annual_ira_contribution", { precision: 12, scale:  2 }),
	goals: jsonb().default([]),
	emergencyFundTarget: numeric("emergency_fund_target", { precision: 12, scale:  2 }),
	netWorth: numeric("net_worth", { precision: 12, scale:  2 }),
	monthlyCashFlow: numeric("monthly_cash_flow", { precision: 12, scale:  2 }),
	monthlyCashFlowAfterContrib: numeric("monthly_cash_flow_after_contrib", { precision: 12, scale:  2 }),
	monteCarloSuccessRate: numeric("monte_carlo_success_rate", { precision: 5, scale:  2 }),
	monteCarloResults: jsonb("monte_carlo_results"),
	netWorthProjections: jsonb("net_worth_projections"),
	optimizationVariables: jsonb("optimization_variables"),
	effectiveTaxRate: numeric("effective_tax_rate", { precision: 5, scale:  2 }),
	marginalTaxRate: numeric("marginal_tax_rate", { precision: 5, scale:  2 }),
	isSelfEmployed: boolean("is_self_employed").default(false),
	spouseIsSelfEmployed: boolean("spouse_is_self_employed").default(false),
	businessIncome: numeric("business_income", { precision: 12, scale:  2 }),
	spouseBusinessIncome: numeric("spouse_business_income", { precision: 12, scale:  2 }),
	businessExpenses: numeric("business_expenses", { precision: 12, scale:  2 }),
	spouseBusinessExpenses: numeric("spouse_business_expenses", { precision: 12, scale:  2 }),
	solo401KContribution: numeric("solo_401k_contribution", { precision: 12, scale:  2 }),
	spouseSolo401KContribution: numeric("spouse_solo_401k_contribution", { precision: 12, scale:  2 }),
	sepIraContribution: numeric("sep_ira_contribution", { precision: 12, scale:  2 }),
	spouseSepIraContribution: numeric("spouse_sep_ira_contribution", { precision: 12, scale:  2 }),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	spouseFirstName: text("spouse_first_name"),
	spouseLastName: text("spouse_last_name"),
	firstName: text("first_name"),
	lastName: text("last_name"),
	dateOfBirth: date("date_of_birth"),
	maritalStatus: varchar("marital_status", { length: 50 }),
	dependents: integer().default(0),
	spouseName: text("spouse_name"),
	spouseDateOfBirth: text("spouse_date_of_birth"),
	state: text(),
	employmentStatus: text("employment_status"),
	taxWithholdingStatus: text("tax_withholding_status"),
	takeHomeIncome: numeric("take_home_income", { precision: 12, scale:  2 }),
	otherIncome: numeric("other_income", { precision: 12, scale:  2 }),
	spouseEmploymentStatus: text("spouse_employment_status"),
	spouseTaxWithholdingStatus: text("spouse_tax_withholding_status"),
	spouseTakeHomeIncome: numeric("spouse_take_home_income", { precision: 12, scale:  2 }),
	savingsRate: numeric("savings_rate", { precision: 12, scale:  2 }),
	assets: jsonb(),
	liabilities: jsonb(),
	primaryResidence: jsonb("primary_residence"),
	additionalProperties: jsonb("additional_properties"),
	totalMonthlyExpenses: numeric("total_monthly_expenses", { precision: 12, scale:  2 }),
	emergencyFundSize: numeric("emergency_fund_size", { precision: 12, scale:  2 }),
	lifeInsurance: jsonb("life_insurance"),
	spouseLifeInsurance: jsonb("spouse_life_insurance"),
	healthInsurance: jsonb("health_insurance"),
	disabilityInsurance: jsonb("disability_insurance"),
	spouseDisabilityInsurance: jsonb("spouse_disability_insurance"),
	autoInsurance: jsonb("auto_insurance"),
	homeownerInsurance: jsonb("homeowner_insurance"),
	umbrellaInsurance: jsonb("umbrella_insurance"),
	businessLiabilityInsurance: jsonb("business_liability_insurance"),
	insurance: jsonb(),
	retirementAccounts: jsonb("retirement_accounts"),
	retirementGoalAge: integer("retirement_goal_age"),
	retirementGoalAmount: numeric("retirement_goal_amount", { precision: 15, scale:  2 }),
	spouseRetirementGoalAge: integer("spouse_retirement_goal_age"),
	socialSecurityStartAge: integer("social_security_start_age"),
	spouseSocialSecurityStartAge: integer("spouse_social_security_start_age"),
	expectedAnnualReturn: numeric("expected_annual_return", { precision: 5, scale:  2 }),
	inflationRate: numeric("inflation_rate", { precision: 5, scale:  2 }),
	riskProfile: jsonb("risk_profile"),
	investorRiskProfile: text("investor_risk_profile"),
	spouseInvestorRiskProfile: text("spouse_investor_risk_profile"),
	financialPriorities: jsonb("financial_priorities"),
	lifeGoals: jsonb("life_goals"),
	majorLifeEvents: jsonb("major_life_events"),
	insuranceAdequacyScore: integer("insurance_adequacy_score"),
	lifeGoalsSuccessProbability: numeric("life_goals_success_probability", { precision: 5, scale:  2 }),
	userRecommendedAssetAllocation: jsonb("user_recommended_asset_allocation"),
	personalizedRecommendations: jsonb("personalized_recommendations"),
	aiInsights: text("ai_insights"),
	calculations: jsonb(),
	lastCalculatedAt: timestamp("last_calculated_at", { mode: 'string' }),
	completionPercentage: numeric("completion_percentage", { precision: 5, scale:  2 }).default('0'),
	plaidSyncEnabled: boolean("plaid_sync_enabled").default(false),
	lastPlaidSync: timestamp("last_plaid_sync", { mode: 'string' }),
	plaidItems: jsonb("plaid_items"),
	plaidInstitutions: jsonb("plaid_institutions"),
	riskQuestionnaire: jsonb("risk_questionnaire"),
	riskQuestions: jsonb("risk_questions"),
	currentAllocation: jsonb("current_allocation"),
	currentStockAllocation: numeric("current_stock_allocation", { precision: 5, scale:  2 }),
	currentBondAllocation: numeric("current_bond_allocation", { precision: 5, scale:  2 }),
	currentCashAllocation: numeric("current_cash_allocation", { precision: 5, scale:  2 }),
	currentAlternativesAllocation: numeric("current_alternatives_allocation", { precision: 5, scale:  2 }),
	targetAllocation: jsonb("target_allocation"),
	spouseAllocation: jsonb("spouse_allocation"),
	spouseTargetAllocation: jsonb("spouse_target_allocation"),
	userRiskProfile: text("user_risk_profile"),
	spouseRiskProfile: text("spouse_risk_profile"),
	spouseRiskQuestions: jsonb("spouse_risk_questions"),
	hasWill: boolean("has_will").default(false),
	hasTrust: boolean("has_trust").default(false),
	hasPowerOfAttorney: boolean("has_power_of_attorney").default(false),
	hasHealthcareProxy: boolean("has_healthcare_proxy").default(false),
	estatePlanningDocuments: jsonb("estate_planning_documents"),
	beneficiaries: jsonb(),
	hasBeneficiaries: boolean("has_beneficiaries").default(false),
	estatePlanning: jsonb("estate_planning"),
	retirementAge: integer("retirement_age"),
	spouseRetirementAge: integer("spouse_retirement_age"),
	estimatedSocialSecurityBenefit: numeric("estimated_social_security_benefit", { precision: 12, scale:  2 }),
	spouseEstimatedSocialSecurityBenefit: numeric("spouse_estimated_social_security_benefit", { precision: 12, scale:  2 }),
	retirementIncome: numeric("retirement_income", { precision: 12, scale:  2 }),
	spouseRetirementIncome: numeric("spouse_retirement_income", { precision: 12, scale:  2 }),
	retirementExpenses: numeric("retirement_expenses", { precision: 12, scale:  2 }),
	retirementLifestyle: text("retirement_lifestyle"),
	pensionIncome: numeric("pension_income", { precision: 12, scale:  2 }),
	spousePensionIncome: numeric("spouse_pension_income", { precision: 12, scale:  2 }),
	otherRetirementIncome: numeric("other_retirement_income", { precision: 12, scale:  2 }),
	additionalNotes: text("additional_notes"),
	advisorNotes: text("advisor_notes"),
	lastReviewDate: timestamp("last_review_date", { mode: 'string' }),
	spousePensionBenefit: numeric("spouse_pension_benefit", { precision: 12, scale:  2 }),
	pensionBenefit: numeric("pension_benefit", { precision: 12, scale:  2 }),
	traditionalIraContribution: numeric("traditional_ira_contribution", { precision: 12, scale:  2 }),
	rothIraContribution: numeric("roth_ira_contribution", { precision: 12, scale:  2 }),
	traditional401KContribution: numeric("traditional_401k_contribution", { precision: 12, scale:  2 }),
	roth401KContribution: numeric("roth_401k_contribution", { precision: 12, scale:  2 }),
	spouseTraditionalIraContribution: numeric("spouse_traditional_ira_contribution", { precision: 12, scale:  2 }),
	spouseRothIraContribution: numeric("spouse_roth_ira_contribution", { precision: 12, scale:  2 }),
	spouseTraditional401KContribution: numeric("spouse_traditional_401k_contribution", { precision: 12, scale:  2 }),
	spouseRoth401KContribution: numeric("spouse_roth_401k_contribution", { precision: 12, scale:  2 }),
	hsaContribution: numeric("hsa_contribution", { precision: 12, scale:  2 }),
	spouseHsaContribution: numeric("spouse_hsa_contribution", { precision: 12, scale:  2 }),
	taxFilingStatus: text("tax_filing_status"),
	stateTaxRate: numeric("state_tax_rate", { precision: 5, scale:  2 }),
	deductions: jsonb(),
	taxCredits: jsonb("tax_credits"),
	lifeExpectancy: integer("life_expectancy"),
	retirementExpenseBudget: jsonb("retirement_expense_budget"),
	retirementIncomeNeeded: numeric("retirement_income_needed", { precision: 12, scale:  2 }),
	retirementIncomeGap: numeric("retirement_income_gap", { precision: 12, scale:  2 }),
	retirementSavingsNeeded: numeric("retirement_savings_needed", { precision: 15, scale:  2 }),
	retirementMonthlySavingsNeeded: numeric("retirement_monthly_savings_needed", { precision: 12, scale:  2 }),
	yearsToRetirement: integer("years_to_retirement"),
	spouseYearsToRetirement: integer("spouse_years_to_retirement"),
	collegeSavingsGoals: jsonb("college_savings_goals"),
	collegeSavings529Plans: jsonb("college_savings_529_plans"),
	collegeSavingsMonthlyNeeded: numeric("college_savings_monthly_needed", { precision: 12, scale:  2 }),
	emergencyFundMonths: integer("emergency_fund_months"),
	emergencyFundGap: numeric("emergency_fund_gap", { precision: 12, scale:  2 }),
	debtToIncomeRatio: numeric("debt_to_income_ratio", { precision: 5, scale:  2 }),
	housingExpenseRatio: numeric("housing_expense_ratio", { precision: 5, scale:  2 }),
	savingsRatio: numeric("savings_ratio", { precision: 5, scale:  2 }),
	investmentHorizon: text("investment_horizon"),
	liquidityNeeds: text("liquidity_needs"),
	taxSituation: text("tax_situation"),
	investmentExperience: text("investment_experience"),
	investmentObjectives: jsonb("investment_objectives"),
	specialCircumstances: text("special_circumstances"),
	healthcareCostsRetirement: numeric("healthcare_costs_retirement", { precision: 12, scale:  2 }),
	longTermCareCosts: numeric("long_term_care_costs", { precision: 12, scale:  2 }),
	inflationAdjustedExpenses: numeric("inflation_adjusted_expenses", { precision: 12, scale:  2 }),
	socialSecurityBenefit: numeric("social_security_benefit", { precision: 12, scale:  2 }),
	spouseSocialSecurityBenefit: numeric("spouse_social_security_benefit", { precision: 12, scale:  2 }),
	retirementContributions: jsonb("retirement_contributions"),
	spouseRetirementContributions: jsonb("spouse_retirement_contributions"),
	expectedRealReturn: numeric("expected_real_return", { precision: 5, scale:  2 }),
	investmentStrategy: text("investment_strategy"),
	withdrawalRate: numeric("withdrawal_rate", { precision: 5, scale:  2 }),
	safeWithdrawalRate: numeric("safe_withdrawal_rate", { precision: 5, scale:  2 }),
	hasLongTermCareInsurance: boolean("has_long_term_care_insurance").default(false),
	spouseHasLongTermCareInsurance: boolean("spouse_has_long_term_care_insurance").default(false),
	legacyGoal: numeric("legacy_goal", { precision: 15, scale:  2 }),
	legacyGoalAge: integer("legacy_goal_age"),
	lastYearAgi: numeric("last_year_agi", { precision: 15, scale:  2 }),
	lastYearTaxesPaid: numeric("last_year_taxes_paid", { precision: 12, scale:  2 }),
	estimatedCurrentYearTaxes: numeric("estimated_current_year_taxes", { precision: 12, scale:  2 }),
	quarterlyTaxPayments: numeric("quarterly_tax_payments", { precision: 12, scale:  2 }),
	deductionAmount: numeric("deduction_amount", { precision: 12, scale:  2 }),
	taxReturns: jsonb("tax_returns"),
	taxRecommendations: jsonb("tax_recommendations"),
	taxEfficiencyScore: integer("tax_efficiency_score"),
	estatePlanningScore: integer("estate_planning_score"),
	investmentOptimizationScore: integer("investment_optimization_score"),
	debtManagementScore: integer("debt_management_score"),
	wealthBuildingScore: integer("wealth_building_score"),
	financialIndependenceScore: integer("financial_independence_score"),
	monthlyCashFlowAfterContributions: numeric("monthly_cash_flow_after_contributions", { precision: 12, scale:  2 }),
	retirementPlanningData: jsonb("retirement_planning_data"),
	monteCarloSimulation: jsonb("monte_carlo_simulation"),
	retirementPlanningUiPreferences: jsonb("retirement_planning_ui_preferences"),
	lastStressTestResults: jsonb("last_stress_test_results"),
	scenarioAnalysis: jsonb("scenario_analysis"),
	sensitivityAnalysis: jsonb("sensitivity_analysis"),
	lastStressTestDate: timestamp("last_stress_test_date", { mode: 'string' }),
	optimalSocialSecurityAge: integer("optimal_social_security_age"),
	spouseOptimalSocialSecurityAge: integer("spouse_optimal_social_security_age"),
	optimalSpouseSocialSecurityAge: integer("optimal_spouse_social_security_age"),
	socialSecurityOptimization: jsonb("social_security_optimization"),
	selfEmploymentIncome: numeric("self_employment_income", { precision: 12, scale:  2 }),
	spouseSelfEmploymentIncome: numeric("spouse_self_employment_income", { precision: 12, scale:  2 }),
	rentalIncome: numeric("rental_income", { precision: 12, scale:  2 }),
	investmentIncome: numeric("investment_income", { precision: 12, scale:  2 }),
	passiveIncome: numeric("passive_income", { precision: 12, scale:  2 }),
	businessType: text("business_type"),
	businessValue: numeric("business_value", { precision: 15, scale:  2 }),
	businessOwnershipPercentage: numeric("business_ownership_percentage", { precision: 5, scale:  2 }),
	hasRetirementPlan: boolean("has_retirement_plan").default(false),
	has401K: boolean("has_401k").default(false),
	hasIra: boolean("has_ira").default(false),
	hasRothIra: boolean("has_roth_ira").default(false),
	hasPension: boolean("has_pension").default(false),
	selfEmployedData: jsonb("self_employed_data"),
	spouseSelfEmployedData: jsonb("spouse_self_employed_data"),
	isComplete: boolean("is_complete").default(false),
	lastUpdated: timestamp("last_updated", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	optimalRetirementAge: jsonb("optimal_retirement_age"),
	bankingAssets: jsonb("banking_assets").default([]),
	investmentAssets: jsonb("investment_assets").default([]),
	retirementAssets: jsonb("retirement_assets").default([]),
	emergencyReadinessScore: jsonb("emergency_readiness_score"),
	financialHealthScore: jsonb("financial_health_score"),
	retirementReadinessScore: jsonb("retirement_readiness_score"),
	riskManagementScore: jsonb("risk_management_score"),
	cashFlowScore: jsonb("cash_flow_score"),
	insuranceScore: integer("insurance_score"),
}, (table) => [
	index("idx_financial_profiles_user").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	index("idx_financial_profiles_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "financial_profiles_user_id_fkey"
		}).onDelete("cascade"),
	unique("financial_profiles_user_id_key").on(table.userId),
	check("financial_profiles_spouse_health_status_check", sql`spouse_health_status = ANY (ARRAY['excellent'::text, 'good'::text, 'fair'::text, 'poor'::text])`),
	check("financial_profiles_user_health_status_check", sql`user_health_status = ANY (ARRAY['excellent'::text, 'good'::text, 'fair'::text, 'poor'::text])`),
]);

export const debtPayoffPlans = pgTable("debt_payoff_plans", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	name: varchar({ length: 255 }).notNull(),
	strategy: varchar({ length: 50 }).notNull(),
	extraPayment: numeric("extra_payment", { precision: 12, scale:  2 }).default('0'),
	targetDate: date("target_date"),
	isActive: boolean("is_active").default(false),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	index("idx_debt_payoff_plans_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("idx_debt_payoff_plans_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "debt_payoff_plans_user_id_fkey"
		}).onDelete("cascade"),
]);

export const widgetCache = pgTable("widget_cache", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	widgetName: text("widget_name"),
	cachedData: jsonb("cached_data"),
	expiresAt: timestamp("expires_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	widgetType: text("widget_type"),
	inputHash: text("input_hash"),
	widgetData: jsonb("widget_data"),
	calculatedAt: timestamp("calculated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	cacheKey: text("cache_key"),
	ttlSeconds: integer("ttl_seconds").default(3600),
	hitCount: integer("hit_count").default(0),
	lastAccessed: timestamp("last_accessed", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	version: text().default('1.0'),
	metadata: jsonb().default({}),
}, (table) => [
	index("idx_widget_cache_expires_at").using("btree", table.expiresAt.asc().nullsLast().op("timestamp_ops")),
	index("idx_widget_cache_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	index("idx_widget_cache_widget_name").using("btree", table.widgetName.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "widget_cache_user_id_fkey"
		}).onDelete("cascade"),
	unique("widget_cache_user_id_widget_name_key").on(table.userId, table.widgetName),
]);

export const dashboardInsights = pgTable("dashboard_insights", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	financialHealthInsights: jsonb("financial_health_insights"),
	retirementInsights: jsonb("retirement_insights"),
	taxInsights: jsonb("tax_insights"),
	investmentInsights: jsonb("investment_insights"),
	estatePlanningInsights: jsonb("estate_planning_insights"),
	riskManagementInsights: jsonb("risk_management_insights"),
	cashFlowInsights: jsonb("cash_flow_insights"),
	debtInsights: jsonb("debt_insights"),
	topPriorities: jsonb("top_priorities"),
	actionItems: jsonb("action_items"),
	opportunities: jsonb(),
	warnings: jsonb(),
	aiAnalysis: text("ai_analysis"),
	aiRecommendations: jsonb("ai_recommendations"),
	lastUpdated: timestamp("last_updated", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	insights: jsonb(),
	generatedByModel: text("generated_by_model").default('gemini-1.5-flash'),
	generationPrompt: text("generation_prompt"),
	generationVersion: text("generation_version").default('1.0'),
	profileHash: text("profile_hash"),
	cacheTtl: integer("cache_ttl").default(3600),
	isStale: boolean("is_stale").default(false),
	financialSnapshot: jsonb("financial_snapshot"),
	profileSnapshot: jsonb("profile_snapshot"),
	insightsMetadata: jsonb("insights_metadata"),
	profileDataHash: text("profile_data_hash"),
	isActive: boolean("is_active").default(true),
	validUntil: timestamp("valid_until", { mode: 'string' }),
	regenerationTriggered: boolean("regeneration_triggered").default(false),
	viewCount: integer("view_count").default(0),
	lastViewed: timestamp("last_viewed", { mode: 'string' }),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
}, (table) => [
	index("idx_dashboard_insights_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "dashboard_insights_user_id_fkey"
		}).onDelete("cascade"),
	unique("dashboard_insights_user_id_key").on(table.userId),
]);

export const plaidAccountMappings = pgTable("plaid_account_mappings", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	plaidAccountId: integer("plaid_account_id"),
	category: text().notNull(),
	subcategory: text(),
	assetType: text("asset_type"),
	owner: text().default('user'),
	allocationPercentage: numeric("allocation_percentage", { precision: 5, scale:  2 }).default('100'),
	includeInCalculations: boolean("include_in_calculations").default(true),
	isEmergencyFund: boolean("is_emergency_fund").default(false),
	isRetirementAccount: boolean("is_retirement_account").default(false),
	isEducationAccount: boolean("is_education_account").default(false),
	customName: text("custom_name"),
	tags: jsonb(),
	notes: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_plaid_account_mappings_category").using("btree", table.category.asc().nullsLast().op("text_ops")),
	index("idx_plaid_account_mappings_owner").using("btree", table.owner.asc().nullsLast().op("text_ops")),
	index("idx_plaid_account_mappings_plaid_account_id").using("btree", table.plaidAccountId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_account_mappings_subcategory").using("btree", table.subcategory.asc().nullsLast().op("text_ops")),
	index("idx_plaid_account_mappings_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.plaidAccountId],
			foreignColumns: [plaidAccounts.id],
			name: "plaid_account_mappings_plaid_account_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_account_mappings_user_id_fkey"
		}),
]);

export const plaidLiabilities = pgTable("plaid_liabilities", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	accountId: varchar("account_id", { length: 255 }).notNull(),
	name: varchar({ length: 255 }),
	type: varchar({ length: 50 }),
	subtype: varchar({ length: 50 }),
	currentBalance: numeric("current_balance", { precision: 12, scale:  2 }),
	interestRate: numeric("interest_rate", { precision: 5, scale:  2 }),
	minimumPayment: numeric("minimum_payment", { precision: 12, scale:  2 }),
	originationDate: date("origination_date"),
	institutionName: varchar("institution_name", { length: 255 }),
	lastSynced: timestamp("last_synced", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	plaidAccountId: integer("plaid_account_id"),
}, (table) => [
	index("idx_plaid_liabilities_plaid_account_id").using("btree", table.plaidAccountId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_liabilities_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.plaidAccountId],
			foreignColumns: [plaidAccounts.id],
			name: "plaid_liabilities_plaid_account_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_liabilities_user_id_fkey"
		}).onDelete("cascade"),
	unique("plaid_liabilities_account_id_key").on(table.accountId),
]);

export const debtPayments = pgTable("debt_payments", {
	id: serial().primaryKey().notNull(),
	debtId: integer("debt_id"),
	paymentDate: date("payment_date").notNull(),
	paymentAmount: numeric("payment_amount", { precision: 10, scale:  2 }).notNull(),
	principalAmount: numeric("principal_amount", { precision: 10, scale:  2 }),
	interestAmount: numeric("interest_amount", { precision: 10, scale:  2 }),
	remainingBalance: numeric("remaining_balance", { precision: 15, scale:  2 }),
	paymentType: text("payment_type").default('regular'),
	notes: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_debt_payments_date").using("btree", table.paymentDate.asc().nullsLast().op("date_ops")),
	index("idx_debt_payments_debt_id").using("btree", table.debtId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.debtId],
			foreignColumns: [debts.id],
			name: "debt_payments_debt_id_fkey"
		}).onDelete("cascade"),
]);

export const plaidInvestmentTransactions = pgTable("plaid_investment_transactions", {
	id: serial().primaryKey().notNull(),
	accountId: integer("account_id"),
	investmentTransactionId: text("investment_transaction_id").notNull(),
	securityId: text("security_id"),
	amount: numeric({ precision: 15, scale:  2 }),
	price: numeric({ precision: 20, scale:  8 }),
	quantity: numeric({ precision: 20, scale:  8 }),
	fees: numeric({ precision: 10, scale:  2 }),
	type: text(),
	subtype: text(),
	isoCurrencyCode: text("iso_currency_code"),
	unofficialCurrencyCode: text("unofficial_currency_code"),
	date: date(),
	datetime: timestamp({ mode: 'string' }),
	name: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_plaid_investment_transactions_account_id").using("btree", table.accountId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_investment_transactions_date").using("btree", table.date.asc().nullsLast().op("date_ops")),
	index("idx_plaid_investment_transactions_security_id").using("btree", table.securityId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.accountId],
			foreignColumns: [plaidAccounts.id],
			name: "plaid_investment_transactions_account_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.securityId],
			foreignColumns: [plaidSecurities.securityId],
			name: "plaid_investment_transactions_security_id_fkey"
		}),
	unique("plaid_investment_transactions_investment_transaction_id_key").on(table.investmentTransactionId),
]);

export const plaidCategories = pgTable("plaid_categories", {
	id: serial().primaryKey().notNull(),
	categoryId: text("category_id").notNull(),
	categoryGroup: text("category_group"),
	hierarchy: text().array(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_plaid_categories_category_group").using("btree", table.categoryGroup.asc().nullsLast().op("text_ops")),
	index("idx_plaid_categories_category_id").using("btree", table.categoryId.asc().nullsLast().op("text_ops")),
	unique("plaid_categories_category_id_key").on(table.categoryId),
]);

export const plaidInvestmentHoldings = pgTable("plaid_investment_holdings", {
	id: serial().primaryKey().notNull(),
	accountId: integer("account_id"),
	securityId: text("security_id"),
	institutionPrice: numeric("institution_price", { precision: 20, scale:  8 }),
	institutionPriceAsOf: date("institution_price_as_of"),
	institutionValue: numeric("institution_value", { precision: 15, scale:  2 }),
	costBasis: numeric("cost_basis", { precision: 15, scale:  2 }),
	quantity: numeric({ precision: 20, scale:  8 }),
	isoCurrencyCode: text("iso_currency_code"),
	unofficialCurrencyCode: text("unofficial_currency_code"),
	vestedQuantity: numeric("vested_quantity", { precision: 20, scale:  8 }),
	vestedValue: numeric("vested_value", { precision: 15, scale:  2 }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	plaidAccountId: integer("plaid_account_id"),
}, (table) => [
	index("idx_plaid_investment_holdings_account_id").using("btree", table.accountId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_investment_holdings_plaid_account_id").using("btree", table.plaidAccountId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_investment_holdings_security_id").using("btree", table.securityId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.accountId],
			foreignColumns: [plaidAccounts.id],
			name: "plaid_investment_holdings_account_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.plaidAccountId],
			foreignColumns: [plaidAccounts.id],
			name: "plaid_investment_holdings_plaid_account_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.securityId],
			foreignColumns: [plaidSecurities.securityId],
			name: "plaid_investment_holdings_security_id_fkey"
		}),
]);

export const plaidIncome = pgTable("plaid_income", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	itemId: integer("item_id"),
	incomeStreams: jsonb("income_streams"),
	lastYearIncome: numeric("last_year_income", { precision: 15, scale:  2 }),
	lastYearIncomeBeforeTax: numeric("last_year_income_before_tax", { precision: 15, scale:  2 }),
	projectedYearlyIncome: numeric("projected_yearly_income", { precision: 15, scale:  2 }),
	projectedYearlyIncomeBeforeTax: numeric("projected_yearly_income_before_tax", { precision: 15, scale:  2 }),
	maxNumberOfOverlappingIncomeStreams: integer("max_number_of_overlapping_income_streams"),
	numberOfIncomeStreams: integer("number_of_income_streams"),
	verificationStatus: text("verification_status"),
	verificationRefreshStatus: text("verification_refresh_status"),
	precheckId: text("precheck_id"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_plaid_income_item_id").using("btree", table.itemId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_income_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.itemId],
			foreignColumns: [plaidItems.id],
			name: "plaid_income_item_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_income_user_id_fkey"
		}),
]);

export const plaidAssetReports = pgTable("plaid_asset_reports", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	assetReportToken: text("asset_report_token").notNull(),
	assetReportId: text("asset_report_id").notNull(),
	daysRequested: integer("days_requested"),
	clientReportId: text("client_report_id"),
	webhook: text(),
	reportData: jsonb("report_data"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	removedAt: timestamp("removed_at", { mode: 'string' }),
}, (table) => [
	index("idx_plaid_asset_reports_token").using("btree", table.assetReportToken.asc().nullsLast().op("text_ops")),
	index("idx_plaid_asset_reports_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_asset_reports_user_id_fkey"
		}),
	unique("plaid_asset_reports_asset_report_token_key").on(table.assetReportToken),
]);

export const plaidRecurringTransactions = pgTable("plaid_recurring_transactions", {
	id: serial().primaryKey().notNull(),
	accountId: integer("account_id"),
	streamId: text("stream_id").notNull(),
	category: text().array(),
	categoryId: text("category_id"),
	description: text(),
	merchantName: text("merchant_name"),
	firstDate: date("first_date"),
	lastDate: date("last_date"),
	frequency: text(),
	transactionIds: text("transaction_ids").array(),
	averageAmount: numeric("average_amount", { precision: 10, scale:  2 }),
	lastAmount: numeric("last_amount", { precision: 10, scale:  2 }),
	isUserModified: boolean("is_user_modified").default(false),
	status: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_plaid_recurring_transactions_account_id").using("btree", table.accountId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_recurring_transactions_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_plaid_recurring_transactions_stream_id").using("btree", table.streamId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.accountId],
			foreignColumns: [plaidAccounts.id],
			name: "plaid_recurring_transactions_account_id_fkey"
		}).onDelete("cascade"),
	unique("plaid_recurring_transactions_stream_id_key").on(table.streamId),
]);

export const plaidInstitutions = pgTable("plaid_institutions", {
	id: serial().primaryKey().notNull(),
	institutionId: text("institution_id").notNull(),
	name: text(),
	products: text().array(),
	countryCodes: text("country_codes").array(),
	url: text(),
	primaryColor: text("primary_color"),
	logo: text(),
	routingNumbers: text("routing_numbers").array(),
	oauth: boolean().default(false),
	status: jsonb(),
	paymentInitiationMetadata: jsonb("payment_initiation_metadata"),
	authMetadata: jsonb("auth_metadata"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_plaid_institutions_institution_id").using("btree", table.institutionId.asc().nullsLast().op("text_ops")),
	index("idx_plaid_institutions_name").using("btree", table.name.asc().nullsLast().op("text_ops")),
	unique("plaid_institutions_institution_id_key").on(table.institutionId),
]);

export const plaidWebhooks = pgTable("plaid_webhooks", {
	id: serial().primaryKey().notNull(),
	itemId: integer("item_id"),
	webhookType: text("webhook_type").notNull(),
	webhookCode: text("webhook_code").notNull(),
	error: text(),
	newTransactions: integer("new_transactions"),
	removedTransactions: text("removed_transactions").array(),
	processed: boolean().default(false),
	processedAt: timestamp("processed_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_plaid_webhooks_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamp_ops")),
	index("idx_plaid_webhooks_item_id").using("btree", table.itemId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_webhooks_processed").using("btree", table.processed.asc().nullsLast().op("bool_ops")),
	index("idx_plaid_webhooks_type").using("btree", table.webhookType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.itemId],
			foreignColumns: [plaidItems.id],
			name: "plaid_webhooks_item_id_fkey"
		}).onDelete("cascade"),
]);

export const plaidSyncRecovery = pgTable("plaid_sync_recovery", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id"),
	plaidItemId: integer("plaid_item_id"),
	errorCode: text("error_code"),
	errorMessage: text("error_message"),
	retryCount: integer("retry_count").default(0),
	lastAttempt: timestamp("last_attempt", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	nextRetry: timestamp("next_retry", { mode: 'string' }),
	resolved: boolean().default(false),
	resolvedAt: timestamp("resolved_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	syncType: varchar("sync_type", { length: 50 }),
	status: text().default('pending'),
	nextRetryAt: timestamp("next_retry_at", { mode: 'string' }),
	lastError: text("last_error"),
	lastAttemptAt: timestamp("last_attempt_at", { mode: 'string' }),
}, (table) => [
	index("idx_plaid_sync_recovery_next_retry").using("btree", table.nextRetry.asc().nullsLast().op("timestamp_ops")),
	index("idx_plaid_sync_recovery_resolved").using("btree", table.resolved.asc().nullsLast().op("bool_ops")),
	index("idx_plaid_sync_recovery_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.plaidItemId],
			foreignColumns: [plaidItems.id],
			name: "plaid_sync_recovery_plaid_item_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_sync_recovery_user_id_fkey"
		}).onDelete("cascade"),
]);

export const debts = pgTable("debts", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	name: varchar({ length: 255 }).notNull(),
	type: varchar({ length: 50 }).notNull(),
	balance: numeric({ precision: 12, scale:  2 }).notNull(),
	interestRate: numeric("interest_rate", { precision: 5, scale:  2 }),
	minimumPayment: numeric("minimum_payment", { precision: 12, scale:  2 }),
	dueDate: integer("due_date"),
	priority: integer().default(0),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	debtName: text("debt_name"),
	debtType: text("debt_type"),
	originalBalance: numeric("original_balance", { precision: 12, scale:  2 }),
	currentBalance: numeric("current_balance", { precision: 12, scale:  2 }),
	annualInterestRate: numeric("annual_interest_rate", { precision: 5, scale:  2 }),
	paymentDueDate: integer("payment_due_date"),
	owner: text(),
	lender: text(),
	accountNumber: text("account_number"),
}, (table) => [
	index("idx_debts_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "debts_user_id_fkey"
		}).onDelete("cascade"),
]);

export const plaidAggregatedSnapshot = pgTable("plaid_aggregated_snapshot", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	snapshotDate: timestamp("snapshot_date", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	totalCash: numeric("total_cash", { precision: 15, scale:  2 }).default('0'),
	totalInvestments: numeric("total_investments", { precision: 15, scale:  2 }).default('0'),
	totalRetirement: numeric("total_retirement", { precision: 15, scale:  2 }).default('0'),
	totalRealEstate: numeric("total_real_estate", { precision: 15, scale:  2 }).default('0'),
	totalOtherAssets: numeric("total_other_assets", { precision: 15, scale:  2 }).default('0'),
	totalAssets: numeric("total_assets", { precision: 15, scale:  2 }).default('0'),
	totalCreditCards: numeric("total_credit_cards", { precision: 15, scale:  2 }).default('0'),
	totalMortgages: numeric("total_mortgages", { precision: 15, scale:  2 }).default('0'),
	totalLoans: numeric("total_loans", { precision: 15, scale:  2 }).default('0'),
	totalOtherLiabilities: numeric("total_other_liabilities", { precision: 15, scale:  2 }).default('0'),
	totalLiabilities: numeric("total_liabilities", { precision: 15, scale:  2 }).default('0'),
	netWorth: numeric("net_worth", { precision: 15, scale:  2 }).default('0'),
	accountsData: jsonb("accounts_data"),
	monthlyIncome: numeric("monthly_income", { precision: 12, scale:  2 }),
	monthlyExpenses: numeric("monthly_expenses", { precision: 12, scale:  2 }),
	monthlyCashFlow: numeric("monthly_cash_flow", { precision: 12, scale:  2 }),
	expensesByCategory: jsonb("expenses_by_category"),
	investmentAllocation: jsonb("investment_allocation"),
	plaidItemsCount: integer("plaid_items_count").default(0),
	accountsCount: integer("accounts_count").default(0),
	lastSyncTimestamp: timestamp("last_sync_timestamp", { mode: 'string' }),
	isComplete: boolean("is_complete").default(false),
	createdAt: timestamp("created_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	updatedAt: timestamp("updated_at", { mode: 'string' }).default(sql`CURRENT_TIMESTAMP`),
	bankingAssets: jsonb("banking_assets").default([]),
	investmentAssets: jsonb("investment_assets").default([]),
	retirementAssets: jsonb("retirement_assets").default([]),
	otherAssets: jsonb("other_assets").default([]),
	liabilities: jsonb().default([]),
	expenseCategories: jsonb("expense_categories").default({}),
	accountSummary: jsonb("account_summary").default({}),
	institutionSummary: jsonb("institution_summary").default({}),
	metadata: jsonb().default({}),
	emergencyFunds: jsonb("emergency_funds").default({}),
	educationFunds: numeric("education_funds", { precision: 15, scale:  2 }).default('0'),
	creditCardDebt: numeric("credit_card_debt", { precision: 15, scale:  2 }),
	studentLoans: numeric("student_loans", { precision: 15, scale:  2 }),
	personalLoans: numeric("personal_loans", { precision: 15, scale:  2 }),
	mortgageDebt: numeric("mortgage_debt", { precision: 15, scale:  2 }),
	autoLoans: numeric("auto_loans", { precision: 15, scale:  2 }),
	otherDebt: numeric("other_debt", { precision: 15, scale:  2 }),
	annualIncome: numeric("annual_income", { precision: 15, scale:  2 }),
	lastSyncDate: timestamp("last_sync_date", { mode: 'string' }),
}, (table) => [
	index("idx_plaid_aggregated_snapshot_date").using("btree", table.snapshotDate.asc().nullsLast().op("timestamp_ops")),
	index("idx_plaid_aggregated_snapshot_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	index("idx_plaid_snapshot_date").using("btree", table.snapshotDate.desc().nullsFirst().op("timestamp_ops")),
	index("idx_plaid_snapshot_user_date").using("btree", table.userId.asc().nullsLast().op("timestamp_ops"), table.snapshotDate.desc().nullsFirst().op("timestamp_ops")),
	index("idx_plaid_snapshot_user_id").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "plaid_aggregated_snapshot_user_id_fkey"
		}).onDelete("cascade"),
	unique("plaid_aggregated_snapshot_user_id_snapshot_date_key").on(table.userId, table.snapshotDate),
]);
